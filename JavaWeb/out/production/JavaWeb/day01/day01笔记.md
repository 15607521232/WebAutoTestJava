### 集合
    集合： 存储对象数据 的集合容器。
    
    单例集合
    
    ----------| Collection  单例集合 的根接口
    ----------------| List 如果是实现了List接口的集合类，具备的特点： 有序，可重复。
    -------------------| ArrayList ArrayList底层是使用了Object数组实现 的。 特点： 查询速度快，增删慢。
    -------------------| LinkedList LinkedList底层是使用了链表数据结构实现的。特点： 查询速度慢，增删快
    -------------------| Vector 底层是使用了Object数组实现 的， 实现原理与ArrayList 是一致的，但是是线程安全的，操作效率低。
    ----------------| Set  如果是实现了Set接口的集合类，具备的特点： 无序，不可重复。
    -------------------| HashSet 底层是使用了哈希表实现 的。 特点： 存取速度快。
    
    HashSet存储元素的原理：
     	往hashSet添加元素的时候，首先会调用元素的hashCode方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。
    	
    	情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。
    		
    	情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素 的equals方法再与这个位置上 的元素比较一次。
    	如果equals方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回 的是false，那么该元素也可以被添加。
    ------------------| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的。 特点： 对集合中的元素进行排序存储、。
    
    TreeSet要注意的事项：
    	1. 往TreeSet添加元素 的时候，如果元素具备自然顺序的特点，那么TreeSet会根据元素 的自然顺序特性进行排序 存储。
    	2. 往TreeSet添加元素 的时候，如果元素不具备自然顺序的特点,那么元素所属的类就必须要实现Comparable接口，把比较的规则定义在CompareTo方法上。
    	3. 往TreeSet添加元素 的时候，如果元素不具备自然顺序的特点,那么元素所属的类就也没有实现Comparable接口，那么在创建TreeSet对象的时候必须要传入比较器对象。
    	
    	比较器 的定义格式:
    		
    			class 类名 implements  Comparator{
    			}
    
    双列集合
    	----------| Map 存储的数据都是以键值对的形式存在的，键可以不重复，值可重复。
    	-------------| HashMap 底层也是使用了哈希表实现的。
    	-------------| TreeMap 底层也是使用了红黑树数据结构实现的。
    泛型 的好处：
     	1. 把运行时出现 的问题提前至了编译时。
     	2. 避免了无谓的强制类型转换。
     	
    
    泛型在集合中的应用：
     	ArrayList<String> list = new ArrayList<String>();  true    true     true
     	
     	ArrayList<Object> list = new ArrayList<String>();  true    true     false
     	ArrayList<String> list = new ArrayList<Object>();  false   true     false
    
    考虑到新老系统兼用性：
     
     	ArrayList   list = new ArrayList<String>();        false   false    true
     	ArrayList<String> list = new ArrayList();          true    false    false
     
    注意： 在泛型中没有多态的概念，两边的数据必须要一致。 或者是只写一边 的泛型类型。
    
    推荐使用： 两边的数据类型都写上一致的。
    
     自定义泛型： 自定义泛型可以理解为是一个数据类型的占位符，或者是理解为是一个数据类型的变量。
     
     泛型方法：
    	
    	泛型方法的定义格式： 
    		
    		修饰符   <声明自定义泛型>返回值类型       函数名(形参列表..){
    		
    		}
    
    注意：
    	1. 在方法上的自定义泛型的具体数据类型是调用该方法的时候传入实参的时候确定的。
    	2. 自定义泛型使用的标识符只要符合标识符的命名规则即可。
    
    
    
    需求： 定义一个函数可以接收任意类型的参数，要求函数的返回值类型与实参的数据类型要一致。
     */
    public class Demo2 {
    
    	public static void main(String[] args) {
    		Integer i= print(12); // Integer
    		String str = print("abc");
    	}
    	
    	
    	//<T> 把T字母声明为自定义 的泛型、
    	public static <abc> abc print(abc o){
    		
    		return o;
    	}
    	
    }
    
     泛型类
     
     泛型类的定义格式：
     	
     	class 类名<声明自定义的泛型>{
     	
     	} 
     
    注意的事项： 
     	1. 在类上自定义的泛型的具体数据类型是在创建对象的时候指定的。
    	2. 在类上自定义了泛型，如果创建该类的对象时没有指定泛型的具体类型，那么默认是Object类型。
    	
    
    //自定义 一个集合对象
    class MyList<T>{
    	
    	Object[]  arr = new Object[10];
    	
    	int index = 0;
    	
    	public MyList(){
    	
    	}
    
    	public void add(T o){
    		arr[index++] = o;
    	} 
    	
    }
    
    
    public class Demo3 {
    	
    	public static void main(String[] args) {
    		MyList<String> list=  new MyList<String>();
    		list.add("123");
    		
    		MyList list2 = new MyList();
    		
    		new ArrayList<String>();
    		
    	}
    	
    }
    
    
     泛型接口：
     
     泛型接口的定义格式：
     	
     	interface 接口名<声明自定义的泛型>{
     	
     	}
     
    在接口上自定义泛型要注意的事项：
     	1. 在接口上自定义泛型的具体数据类型是在实现该接口的时候指定的。
     	2. 如果一个接口自定义了泛型，在实现该接口的时候没有指定具体的数据类型，那么默认是Object数据类型。 
     
     如果想在创建接口实现类对象的时候再指定接口自定义泛型 的具体数据类型？


### IO复习
    IO解决问题： 解决设备与设备之间 的数据传输问题。  比如： 硬盘--->内存            内存----->硬盘
    
    字节流:
    
    输入字节流：
    ---------| InputStream 所有输入字节流的基类。 抽象类。
    ------------| FileInputStream 读取文件的输入字节流。
    ------------| BufferedInputStream 缓冲输入字节流。 该类内部其实就是维护了一个8kb字节数组而已。  该类出现的目的是为了提高读取文件数据的效率。
    
    输出字节流:
    ---------| OutputStream  所有输出字节流的基类。  抽象类。
    ------------| FileOutputStream 向文件输出数据 的输出字节流。
    ------------| BufferedOutputStream  缓冲输出字节流。 该类出现的目的是为了提高向文件写数据的效率。 该类内部其实也是维护了一个8kb的字节数组而已。
    
    
    什么情况使用字节流： 读取到数据不需要经过编码或者解码的情况情况下这时候使用字节流。比如：图片数据
    
    
    字符流 = 字节流 + 编码（解码）
    
    字符流:
    
    输入字符流
    --------| Reader 所有输入字符流的基类。 抽象类。
    -----------| FileReader 读取文件字符的输入字符流。 
    -----------| BufferedReader 缓冲输入字符流。 该类出现的目的是为了提高读取文件字符的效率并且拓展了功能（readLine()），它内部 其实就是维护了一个8192个长度的字符数组。
    
    输出字符流
    -------| Writer 所有输出字符流的基类。 抽象类。
    ------------| FileWriter 向文件输出字符数据的输出字符流。
    ---------------| BufferedWriter 缓冲输出字符流。该类出现的目的是为了提高写文件字符的效率并且拓展了功能（newLine()）。
    
    什么情况下使用字符流：如果读写的都是字符数据，这时候我们就使用字符流。
    
    
    转换流:
    
    输入字节流的转换流             输入字节流---------输入字符流
    	InputSrteamReader 
    
    输出字节流的转换流
    	OutputStreamWriter
    
    转换流的作用：
    	1. 可以把对应的字节流转换成字符流使用。
    	2. 可以指定码表进行读写文件的数据。
    	
    
    
    FileReader， FileWriter这两个类默认是使用的是gbk编码 表。不能由你来指定码表读写文件数据。
### 线程
         多线程的好处： 多线程解决了在一个进程中同时可以执行多个任务代码的问题。
    
    
    自定义线程的创建方式：
    
    	
    	方式一：继承Thread.
    		1. 自定义一个类继承Thread类。
    		2. 重写Thread的run方法，把自定义线程的任务代码定义在run方法上。
    		3. 创建Thread子类的对象，并且调用start方法启动一个线程。
    
    	
    	方式二： 实现Runnable接口。
    		1. 自定义一个类实现Runnable接口。
    		2. 实现Runnable接口中的run方法，把自定义线程的任务代码定义在run方法上。
    		3. 创建Runable实现类 的对象。
    		4. 创建Thread对象，并且把Runnable实现类的对象作为参数传递。
    		5. 调用Thread对象的start方法开启线程。
    		
    线程安全 问题的解决方案：
    
    线程安全问题出现 的根本原因：
    	1. 必须要存在两个或者两个以上的线程共享着一个资源。
    	2. 操作共享资源的代码必须有两句或者两句以上。
    	
    
    
    	1. 同步代码块
    		
    		synchronized(锁){
    			需要被同步的代码
    		}
    		
    		
    		
    	2. 同步函数。
    		
    		修饰符 synchronized 返回值类型   函数名(形参列表..){
    		
    		}
    		
    		
    	注意：
    		1. 同步代码块的锁可以是任意的对象。 同步函数的锁是固定 的，非静态函数的锁对象是this对象。 静态函数的锁对象是class对象。
    		2. 锁对象必须是多线程共享的对象，否则锁不住。
    		3. 在同步代码块或者是同步函数中调用sleep方法是不会释放锁对象的，如果是调用了wait方法是会释放锁对象的。

### junit(单元测试框架)
    目前存在的问题：
    	1. 目前的方法如果需要测试，都需要在main方法上调用。
    	2. 目前的结果都需要我们人工对比。
    
    
    junit要注意的细节：
    	1. 如果使用junit测试一个方法的时候，在junit窗口上显示绿条那么代表测试正确，
    		如果是出现了红条，则代表该方法测试出现了异常不通过。
    	2. 如果点击方法名、 类名、包名、 工程名运行junit分别测试的是对应的方法，类、 包中 的所有类的test方法，工程中的所有test方法。
    	3.  @Test测试的方法不能是static修饰与不能带有形参。
    	4. 如果测试一个方法的时候需要准备测试的环境或者是清理测试的环境，那么可以@Before、 @After 、@BeforeClass、 @AfterClass这四个注解。
    	@Before、 @After 是在每个测试方法测试的时候都会调用一次， @BeforeClass、 @AfterClass是在所有的测试方法测试之前与测试之后调用一次而已。
    
    junit使用规范：
    	1. 一个类如果需要测试，那么该类就应该对应着一个测试类，测试类的命名规范 ： 被测试类的类名+ Test.
    	2. 一个被测试的方法一般对应着一个测试的方法，测试的方法的命名规范是： test+ 被测试的方法的方法名
   
### 内省
    为什么学习内省
    开发框架时，经常需要使用java对象的属性来封装程序的数据，每次都使用反射技术完成此类操作过于麻烦，所以sun公司开发了一套API，专门用于操作java对象的属性
    
    BeanUtils：
  
    BeanUtils主要解决 的问题： 把对象的属性数据封装 到对象中。
  
    BeanUtils的好处：
    1. BeanUtils设置属性值的时候，如果属性是基本数据 类型，BeanUtils会自动帮我转换数据类型。
    2. BeanUtils设置属性值的时候底层也是依赖于get或者Set方法设置以及获取属性值的。
    3. BeanUtils设置属性值,如果设置的属性是其他的引用 类型数据，那么这时候必须要注册一个类型转换器。
    BeanUtilss使用的步骤：
    1. 导包commons-logging.jar 、 commons-beanutils-1.8.0.jar  

### 路径
    如果经常会发生变化的数据我们可以定义在配置文件上。 比如说：数据库的用户名与密码。
     
    配置文件的路径应该如何写 呢？
    	
    	绝对路径：一个文件的完整路径信息。一般绝对路径是包含有盘符 的。  绝对路径的缺陷： 因为绝对路径是有盘符开头的，有些系统是没有盘符的。
    	
    	相对路径: 相对路径是相对于当前程序的路径。当前路径就是执行java命令的时候，控制台所在的路径。
    	
    	类文件路径 :类文件路径就是使用了classpath的路径找对应的资源文件。
    	
    	如果需要使用到类文件路径首先先要获取到一个Class对象。    		    